Concurrencia

Go provee construciones de concurrencia como parte del core del lenguaje. Esta lección presenta y entrega algunos ejemplos de como ellos pueden usarse.

Los Autores de Go
https://golang.org

* Gorutinas

Una _gorutina_ es un hilo ligero manejado por la runtime de Go.


	go f(x, y, z)

inicia una nueva gorutina

	f(x, y, z)

La evaluación de `f`, `x`, `y`, y `z` ocurre en la gorutina en curso y la ejecución de `f`  ocurre en la nueva gorutina.

Las gorutinas se ejecutan en el mismo espacio de direcciones, así que el acceso a memoria compartida debe estar sincronizado. El paquete [[https://golang.org/pkg/sync/][`sync`]] provee algunas primitivas utiles para ello, aunque ud. no las necesitará mucho en Go ya que hay otras primitivas. (Ver en la siguiente diapositiva)

.play concurrency/goroutines.go

* Canales

Canales son un conducto tipado a través del cual ud. puede envíar y recibir valores con el operador de canal, `<-`.

	ch <- v    // Envia v al canal ch.
	v := <-ch  // Recive desde ch, y
	           // asigna valor a v.

(El flujo de los datos sigue la dirección de la flecha.)

Como los mapas y slices, los canales deben crearse antes de usarse:

	ch := make(chan int)

Por defecto, enviar y recibir a través de un canal bloquea hasta que el otro lado está listo. Esto permite a la gorutinas sincronizarce sin bloqueos explicitos o variables condicionales.

El código de ejemplo suma los números en un slice, distribuyendo el trabajo entre dos gorutinas.
Una vez que ambas gorutinas han completado sus cálculos, se calcula el resultado final.

.play concurrency/channels.go

* Canales con Buffer

A los canales se les puede aplicar un _buffer_. Provea el largo del buffer como el segundo argumento para que `make` inicialice el canal con un buffer.

	ch := make(chan int, 100)

Envíos a un canal con buffer bloquean solo cuando el buffer esta lleno. Recepciones bloquean cuando el buffer está vacio.

Modifique el ejemplo para sobrepasar el buffer y ver que pasa.


.play concurrency/buffered-channels.go

* Range y Close

Quien envía a través de un canal puede `cerrarlo` para indicar que no se enviaran mas valores por el. Receptores pueden probar si un canal ha sido cerrado asignando un segundo un segundo parámetro a la expresión: 

	v, ok := <-ch

`ok` es `false` si no hay mas valores para recibir y el canal está cerrado.

El loop `for`i`:=`range`c` recive valores desde el canal repetidamente hasta que se cierra.

*Nota:* Solo quien envía debería cerrar un canal, nunca el receptor. Envíar a un canal cerrado causara un panic.

*Otra*nota:* Los canales no son archivos; usualmente no necesitas cerrarlos. Cerrarlos es solo necesario cuando el receptor debe ser avisado de que no llegarán mas valores, por ejemplo, para terminar un loop `range`.

.play concurrency/range-and-close.go

* Select

El estamento `select` permite que una gorutina espere a multiples operaciones de comunicación.

Un `select` bloquea hasta que uno de sus cases pueda ejecutarse, entonces lo ejecuta. Escoge un case al azar si varios de ellos están listos.

.play concurrency/select.go

* Selección por Default

El case `default` en un `select` se ejecuta si no hay otro case listo.

Use a `default` case to try a send or receive without blocking:

	select {
	case i := <-c:
		// use i
	default:
		// receiving from c would block
	}

.play concurrency/default-selection.go

* Ejercicio: Arboles binarios equivalentes

Pueden haber diferentes tipos de arboles binarios con la misma secuencia de valores. Por ejemplo, aquí hay dos arboles binarios guardando la secuencia 1, 1, 2, 3, 5, 8, 13.

.image /content/img/tree.png

Una función para verificar si dos arboles binarios guardan la misma secuencia es bastante compleja en otros lenguajes. Usaremos la concurrencia y los canales de Go para escribir una solución simple.

Este ejemplo usa el paquete `tree`, el cual define el tipo:

	type Tree struct {
		Left  *Tree
		Value int
		Right *Tree
	}


Continue description on [[javascript:click('.next-page')][next page]].

* Ejercicio: Arboles binarios equivalentes.

*1.* Implemente la función `Walk`.

*2.* Pruebe la función `Walk`.

La función `tree.New(k)` construye un aleatoreamente estructurado (pero siempre ordenado) árbol binario conteniendo los valores `k`, `2k`, `3k`, ..., `10k`.

Crea un nuevo canal `ch` e inicia el recorrido:

	go Walk(tree.New(1), ch)

Entonces lee e imprime 10 valores por el canal. Deberían ser los números 1, 2, 3, ..., 10.

*3.* Implemente la función `Same` usando `Walk` para determinar si `t1` y `t2` almacenan los mismos valores.

*4.* Pruebe la función `Same`.

`Same(tree.New(1),`tree.New(1))` debería devolver true, y `Same(tree.New(1),`tree.New(2))` debería devolver false.

Puede encontrar la documentación de `Tree` [[https://godoc.org/golang.org/x/tour/tree#Tree][aquí]].

.play concurrency/exercise-equivalent-binary-trees.go

* sync.Mutex

We've seen how channels are great for communication among goroutines.

But what if we don't need communication? What if we just want to make sure only
one goroutine can access a variable at a time to avoid conflicts?

This concept is called _mutual_exclusion_, and the conventional name for the data structure that provides it is _mutex_.

Go's standard library provides mutual exclusion with
[[https://golang.org/pkg/sync/#Mutex][`sync.Mutex`]] and its two methods:

- `Lock`
- `Unlock`

We can define a block of code to be executed in mutual exclusion by surrounding it
with a call to `Lock` and `Unlock` as shown on the `Inc` method.

We can also use `defer` to ensure the mutex will be unlocked as in the `Value` method.

.play concurrency/mutex-counter.go

* Exercise: Web Crawler

In this exercise you'll use Go's concurrency features to parallelize a web crawler.

Modify the `Crawl` function to fetch URLs in parallel without fetching the same URL twice.

_Hint_: you can keep a cache of the URLs that have been fetched on a map, but maps alone are not
safe for concurrent use!

.play concurrency/exercise-web-crawler.go

* Where to Go from here...

#appengine: You can get started by
#appengine: [[https://golang.org/dl/][installing Go]].

#appengine: Once you have Go installed, the
The
[[https://golang.org/doc/][Go Documentation]] is a great place to
#appengine: continue.
start.
It contains references, tutorials, videos, and more.

Para aprender a organizar y trabajar con código Go, lea [[https://golang.org/doc/code][Como escribir código Go]].

si necesita ayuda con la librería estándar, vea la [[https://golang.org/pkg/][referencia de paqueres]]. Para ayuda cone l lenguaje en sí, podría sorprenderse al ver que la [[https://golang.org/ref/spec][Especificación del Lenguage]] es bastante legible.

To further explore Go's concurrency model, watch
[[https://www.youtube.com/watch?v=f6kdp27TYZs][Go Concurrency Patterns]]
([[https://talks.golang.org/2012/concurrency.slide][slides]])
and
[[https://www.youtube.com/watch?v=QDDwwePbDtw][Advanced Go Concurrency Patterns]]
([[https://talks.golang.org/2013/advconc.slide][slides]])
and read the
[[https://golang.org/doc/codewalk/sharemem/][Share Memory by Communicating]]
codewalk.

To get started writing web applications, watch
[[https://vimeo.com/53221558][A simple programming environment]]
([[https://talks.golang.org/2012/simple.slide][slides]])
and read the
[[https://golang.org/doc/articles/wiki/][Writing Web Applications]] tutorial.

The [[https://golang.org/doc/codewalk/functions/][First Class Functions in Go]] codewalk gives an interesting perspective on Go's function types.

The [[https://blog.golang.org/][Go Blog]] has a large archive of informative Go articles.

Visit [[https://golang.org][golang.org]] for more.

